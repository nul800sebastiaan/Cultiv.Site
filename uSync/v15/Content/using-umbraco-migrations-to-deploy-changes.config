<?xml version="1.0" encoding="utf-8"?>
<Content Key="cfada670-108b-4789-85aa-ca031e71bff9" Alias="Using Umbraco migrations to deploy changes" Level="3">
  <Info>
    <Parent Key="63f8fc44-6b65-4c47-a1c4-ba11a5fd981a">Blog</Parent>
    <Path>/Site/Blog/UsingUmbracoMigrationsToDeployChanges</Path>
    <Trashed>false</Trashed>
    <ContentType>blogPost</ContentType>
    <CreateDate>2016-03-27T11:03:24</CreateDate>
    <NodeName Default="Using Umbraco migrations to deploy changes" />
    <SortOrder>44</SortOrder>
    <Published Default="true" />
    <Schedule />
    <Template Key="a649a8ca-c7c4-4bd2-a252-d002b5483d44">BlogPost</Template>
  </Info>
  <Properties>
    <bodyText>
      <Value><![CDATA[<p>In yesterday's blog post I boldly claimed that it's "just as easy" to create a custom table for a counter. Well, this is kinda true, kinda not true. It's really easy to go into your local SQL instance, create a table with two columns and use a bit of PetaPoco to insert or update it, this part is true. Then you have to deploy this change to your staging environment.. rinse, repeat. You will have to find a way to create that same table in an existing database. This gets harder when you don't have (easy) access to the database on the remote server.</p>
<p>This is where Umbraco migrations come in. Migrations were introduced in version 6 of Umbraco to help us change database schema's during an upgrade of Umbraco. Migrations use code instead of using SQL upgrade scripts, while scripts are nice they are limited to executing SQL. We realized that sometimes there's a need to execute some code during upgrades as well. For example: we sometimes want to migrate data that is difficult to handle in a SQL script but would be really easy to deal with using a bit of code.</p>
<p>As of Umbraco version 7.3 these migrations are also very useful for making schema changes in different environments by just deploying your code, no more need to write manual SQL scripts that need to run on each environment.</p>
<h3>How it works</h3>
<p>In the Umbraco database we have a table called umbracoMigration that tracks which migrations have ran for that specific database, so on a fresh 7.4.2 install you'd see the following:</p>
<p><img style="width: 500px; height: 172.52396166134187px;" src="/media/ab6aca1a0c6d4e2fbf2d24d87a9a37bb/00000006000000000000000000000000/2016-03-27_131624.png" alt="" rel="1667" data-id="0" data-udi="umb://media/ab6aca1a0c6d4e2fbf2d24d87a9a37bb"></p>
<p>When Umbraco starts, the first thing it does is that it gets the current version of Umbraco using `Umbraco.Core.Configuration.UmbracoVersion.Current` which in this case is 7.4.2 but when you update the Umbraco dlls to version 7.4.3 it will return 7.4.3. If Umbraco then cannot find the migration with name "Umbraco" and version "7.4.3" in the database, you will get the upgrade installer screen. </p>
<p><img style="width: 500px; height: 352.24274406332455px;" src="/media/1d68622994974246a41532e548642d50/00000006000000000000000000000000/2016-03-27_132200.png" alt="" rel="1563" data-id="0" data-udi="umb://media/1d68622994974246a41532e548642d50"></p>
<p>Once you click the Continue button Umbraco goes and finds all of the classes that have a `Migration` attribute with a version between the newest version in the `umbracoMigration` table and the `<span>Umbraco.Core.Configuration.UmbracoVersion.Current</span>` version. For example, if I've upgraded my Umbraco dlls from 7.3.5 to 7.4.2 it would find migrations targetting versions higher than 7.3.5 and lower than or equal to 7.4.2.</p>
<p><img style="width: 500px; height: 269.54976303317534px;" src="/media/9191d769ea104c57b553a72f4180a988/00000006000000000000000000000000/2016-03-27_132402.png" alt="" rel="1646" data-id="0" data-udi="umb://media/9191d769ea104c57b553a72f4180a988"></p>
<p>We don't do any migrations for patch releases, only for minor and major versions (remember a version is: major.minor.patch). So in reality the upgrade from 7.3.5 to 7.4.2 would only find migrations targeting version 7.4.0 like the ones above. After these have been executed, a new entry will appear in the `umbracoMigration` table, indicating the latest migration that ran on this database. For the Our Umbraco database, for example, you can see exactly which upgrades were done when:</p>
<p><img style="width: 352px; height: 248px;" src="/media/9a1e1eeb7d73405f88c5bec81c3abff2/00000006000000000000000000000000/2016-03-27_133234.png" alt="" rel="1655" data-id="0" data-udi="umb://media/9a1e1eeb7d73405f88c5bec81c3abff2"></p>
<p>The important part to understand about this is that when you deploy your website to the next environment, it will do this same comparison: find `Umbraco.Core.Configuration.UmbracoVersion.Current` and compare that to the highest migration in the `umbracoMigration` table. They will be different because the migration only ran on our local environment. You will again see the upgrade screen on your website, click continue and the migrations run on that environment after which the upgrade is complete. This means that any environment you deploy to will be consistent. </p>
<p><strong>Sidenote</strong>: we didn't always use to do this and people would often forget to run the upgrade installer after deploying their upgraded website from local to the next environment. Most times this wasn't a problem, but when there was actually changes to be made to the database they might have been forgotten, leading to an inconsistent database, leading to problems later on. This is also why you sometimes see database upgrade errors when these migrations run, at some point the proper changes were not made to your database years ago, leading to wrong assumptions on our end and an inability to upgrade your database.</p>
<h3>You too can do this</h3>
<p>Long story short: migrations are great! Now let's see how you can utilize them.</p>
<p>The table that I mentioned in my previous blog post could, for example) consist of a nodeId (a reference to a page in Umbraco) and a count (the number of times this page was visited). In this example we're going to be Umbraco's ORM called PetaPoco, and when using that, we can describe the table we want to use in a C# class like so:</p>
<pre> using Umbraco.Core.Persistence;<br><br> namespace Example.Models<br> {<br>   [TableName("Statistics")]<br>   [PrimaryKey("nodeId", autoIncrement = false)]<br>   public class Statistics<br>   {<br>     [Column("nodeId")]<br>     public int NodeId { get; set; }<br><br>     [Column("count")]<br>     public int Count { get; set; }<br>   }<br> }</pre>
<p>In order to build a migration, we can make a class that has the `Migration` attribute and inherits from `MigrationBase`. Inheriting from that requires you to implement the `Up()` and the `Down()` methods, for doing and upgrade and, if necessary, a downgrade.</p>
<pre>using Example.Models;<br>using Umbraco.Core;<br>using Umbraco.Core.Logging;<br>using Umbraco.Core.Persistence;<br>using Umbraco.Core.Persistence.Migrations;<br>using Umbraco.Core.Persistence.SqlSyntax;<br><br>namespace Example.Migrations<br>{<br>  [Migration("1.0.0", 1, "Statistics")]<br>  public class CreateStatisticsTable : MigrationBase<br>  {<br>    private readonly UmbracoDatabase _database = ApplicationContext.Current.DatabaseContext.Database;<br>    private readonly DatabaseSchemaHelper _schemaHelper;<br><br>    public CreateStatisticsTable(ISqlSyntaxProvider sqlSyntax, ILogger logger) <br>      : base(sqlSyntax, logger)<br>    {<br>      _schemaHelper = new DatabaseSchemaHelper(_database, logger, sqlSyntax);<br>    }<br><br>    public override void Up()<br>    {<br>      _schemaHelper.CreateTable&lt;Statistics&gt;(false);<br> <br>      // Remember you can execute ANY code here and in Down().. <br>      // Anything you can think of, go nuts (not really!)<br>    }<br><br>    public override void Down()<br>    {<br>      _schemaHelper.DropTable&lt;Statistics&gt;();<br>    }<br>  }<br>}</pre>
<p>The migration attribute needs to be provided with a version number, since we're just starting out this is set to "1.0.0". The next argument is the sort order, if there's multiple migrations necessary to upgrade to "Statistics" version 1.0.0 you can run them in the correct order. We use the `Statistics` class we created to describe the table earlier to create or drop the table.</p>
<p>Finally, we need to make this migration run. Since the attribute has the third argument "Statistics" it will not run and trigger when you upgrade Umbraco, only migrations with the name "Umbraco" run automatically. So we need to run it manually somehow. In the future we want to change Umbraco so that it also runs your custom migrations through the Umbraco upgrade installer, for now you'll need to handle it yourself.</p>
<p>In order to run this, we can create an EventHandler that runs when Umbraco starts. In this event handler we will look for the newest migration that ran for the "Statistics" product to check if we need to actually run any migrations. If the database tells us: version 1.0.0 of "Statistics" has been ran, we do nothing. If the version doesn't exist or is lower than the current version, we of course need to run the migration to get the database in a consistent state.</p>
<pre>using System;<br>using System.Linq;<br>using Semver;<br>using Umbraco.Core;<br>using Umbraco.Core.Logging;<br>using Umbraco.Core.Persistence.Migrations;<br>using Umbraco.Web;<br><br>namespace Example.Eventhandlers<br>{<br>  public class MigrationEvents : ApplicationEventHandler<br>  {<br>    protected override void ApplicationStarted(UmbracoApplicationBase umbracoApplication, ApplicationContext applicationContext)<br>    {<br>      HandleStatisticsMigration();<br>    }<br><br>    private static void HandleStatisticsMigration()<br>    {<br>      const string productName = "Statistics";<br>      var currentVersion = new SemVersion(0, 0, 0);<br><br>      // get all migrations for "Statistics" already executed<br>      var migrations = ApplicationContext.Current.Services.MigrationEntryService.GetAll(productName);<br><br>     // get the latest migration for "Statistics" executed<br>     var latestMigration = migrations.OrderByDescending(x =&gt; x.Version).FirstOrDefault();<br><br>     if (latestMigration != null)<br>       currentVersion = latestMigration.Version;<br><br>     var targetVersion = new SemVersion(1, 0, 0);<br>     if (targetVersion == currentVersion)<br>       return;<br><br>     var migrationsRunner = new MigrationRunner(<br>       ApplicationContext.Current.Services.MigrationEntryService,<br>       ApplicationContext.Current.ProfilingLogger.Logger,<br>       currentVersion,<br>       targetVersion,<br>       productName);<br><br>     try<br>     {<br>       migrationsRunner.Execute(UmbracoContext.Current.Application.DatabaseContext.Database);<br>     }<br>     catch (Exception e)<br>     {<br>       LogHelper.Error&lt;MigrationEvents&gt;("Error running Statistics migration", e);<br>     }<br>   }<br> }<br>}</pre>
<p><strong>Note:</strong> for versions before 7.4.2 you'll need to build in an extra `catch` as Umbraco was doing something silly, which is now fixed. So before the `catch (Exception e)` you can add a specific `catch`</p>
<pre>catch (System.Web.HttpException e)<br>{<br>  // because umbraco runs some other migrations after the migration runner <br>  // is executed we get httpexception<br>  // catch this error, but don't do anything<br>  // fixed in 7.4.2+ see : http://issues.umbraco.org/issue/U4-8077<br>}</pre>
<p>Cool, we now have a new table we can use and the migration has been noted for our local database. When we deploy this site, the migration will run again as it's not been recorded in that database yet.</p>
<p><img style="width: 500px; height: 286.63446054750403px;" src="/media/3c079577d0434edfbd5b210e36b4fba1/00000006000000000000000000000000/2016-03-27_141827.png" alt="" rel="1588" data-id="0" data-udi="umb://media/3c079577d0434edfbd5b210e36b4fba1"></p>
<p>Just as some code to test this I've added the counter to my Master template so it will execute on each page, it's not great architecture but it at least allows me to do some quick testing.</p>
<pre>@{<br>   Layout = null;<br><br>   var database = ApplicationContext.Current.DatabaseContext.Database;<br><br>   var query = new Sql()<br>       .Select("*")<br>       .From&lt;Statistics&gt;()<br>       .Where&lt;Statistics&gt;(x =&gt; x.NodeId == Model.Content.Id);<br><br>   var result = database.Fetch&lt;Statistics&gt;(query).FirstOrDefault();<br><br>   if (result == null)<br>   {<br>     database.Insert(new Statistics { NodeId = Model.Content.Id, Count = 1 });<br>   }<br>   else<br>   {<br>     result.Count = result.Count + 1;<br>     database.Update(result);<br>   }<br>}<br>&lt;span&gt;Views: @(result == null ? 1 : result.Count) - NodeId: @Model.Content.Id&lt;/span&gt;</pre>
<p>And after a few refreshes of the page I can see that this works like a charm.</p>
<p><img style="width: 500px; height: 277.39130434782606px;" src="/media/2d19f9482f1a4716b2003dd6a6c818c9/00000006000000000000000000000000/2016-03-27_142016.png" alt="" rel="1575" data-id="0" data-udi="umb://media/2d19f9482f1a4716b2003dd6a6c818c9"></p>
<p>And in our browser:</p>
<p><img style="width: 266px; height: 69px;" src="/media/d384b2006ea2428e8be93e3d238c420d/00000006000000000000000000000000/2016-03-27_143920.png" alt="" rel="1690" data-id="0" data-udi="umb://media/d384b2006ea2428e8be93e3d238c420d"></p>
<p>Now imagine you want to count things in different categories, like PageViews, Downloads, Clicks, etc. You can still use this table but you might want to add a category name to it so you can track different types of counters. </p>
<p>First, we can update our `Statistics` class and add the Category there. </p>
<pre>  [Column("category")]<br>  public string Category { get; set; }</pre>
<p>Then we can add a new migration that adds a column to the existing table.</p>
<pre>using Umbraco.Core.Logging;<br>using Umbraco.Core.Persistence.Migrations;<br>using Umbraco.Core.Persistence.SqlSyntax;<br><br>namespace Example.Migrations<br>{<br>  [Migration("1.0.1", 1, "Statistics")]<br>  public class AddCategoryToStatisticsTable : MigrationBase<br>  {<br>    public AddCategoryToStatisticsTable(ISqlSyntaxProvider sqlSyntax, ILogger logger) <br>      : base(sqlSyntax, logger)<br>    { }<br><br>    public override void Up()<br>    {<br>      Alter.Table("Statistics").AddColumn("Category").AsString().Nullable();<br>    }<br><br>    public override void Down()<br>    {<br>      Delete.Column("Category").FromTable("Statistics");<br>    }<br>  }<br>}</pre>
<p>The last thing we need to do is tell the EventHandler that we're expecting our "Statistics" product to be of a new version now, 1.0.1. Note that the migration above is also created to update the product to version 1.0.1.</p>
<pre>    var targetVersion = new SemVersion(1, 0, 1);</pre>
<p>When this runs we can see in the `umbracoMigration` table that, once again, the migration ran. We also see the new column on the `Statistics` table that we have there.</p>
<p><img id="__mcenew" src="/media/a9a00b6b85be4ad0bd72056e179e8abd/00000006000000000000000000000000/2016-03-27_143330.png" alt="" rel="1664" data-id="0" data-udi="umb://media/a9a00b6b85be4ad0bd72056e179e8abd"></p>
<p>A quick update of our code now allows us to log the category of our counter as well.</p>
<pre>@using Example.Models<br>@using Umbraco.Core.Persistence<br>@inherits UmbracoTemplatePage<br>@{<br>   Layout = null;<br><br>   var database = ApplicationContext.Current.DatabaseContext.Database;<br>   var category = "PageView";<br><br>   var query = new Sql()<br>       .Select("*")<br>       .From&lt;Statistics&gt;()<br>       .Where&lt;Statistics&gt;(x =&gt; x.NodeId == Model.Content.Id &amp;&amp; x.Category == category);<br><br>   var result = database.Fetch&lt;Statistics&gt;(query).FirstOrDefault();<br><br>   if (result == null)<br>   {<br>     database.Insert(new Statistics { NodeId = Model.Content.Id, Count = 1, Category == category });<br>   }<br>   else<br>   {<br>     result.Count = result.Count + 1;<br>     database.Update(result);<br>   }<br>}<br>&lt;span&gt;Views: @(result == null ? 1 : result.Count) - NodeId: @Model.Content.Id&lt;/span&gt;</pre>
<h3>Conclusion</h3>
<p>This post was very much inspired by <a href="https://our.umbraco.org/forum/umbraco-as-a-service/75800-guide-for-custom-tables-in-uaas">a recent question on the forum and the answers there</a>, where I learned not to do this in a "hacky" way.</p>
<p>In this article we've seen that we can create migrations, "things" that need to be executed once on each environment that you deploy your website to. These "things" could be database tables, but you could also imagine that you might want to add a property to a document type, anything is possible. Migrations can help you make sure that all of your environments are in a consistent state when you deploy it to the next environment.</p>]]></Value>
    </bodyText>
    <image>
      <Value><![CDATA[umb://media/a6067fa56ebd4d9f97ffd81c5ff8e1c1]]></Value>
    </image>
    <pageTitle>
      <Value><![CDATA[]]></Value>
    </pageTitle>
    <searchEngineSitemapChangeFrequency>
      <Value><![CDATA[]]></Value>
    </searchEngineSitemapChangeFrequency>
    <searchEngineSitemapPriority>
      <Value><![CDATA[]]></Value>
    </searchEngineSitemapPriority>
    <stillRelevant>
      <Value><![CDATA[1]]></Value>
    </stillRelevant>
    <umbracoNaviHide>
      <Value><![CDATA[]]></Value>
    </umbracoNaviHide>
  </Properties>
</Content>