<?xml version="1.0" encoding="utf-8"?>
<Content Key="68e6cc61-9342-4ad1-a7c1-caef5cf46bc4" Alias="Let's Encrypt on Windows revisited" Level="3">
  <Info>
    <Parent Key="63f8fc44-6b65-4c47-a1c4-ba11a5fd981a">Blog</Parent>
    <Path>/Site/Blog/LetsEncryptOnWindowsRevisited</Path>
    <Trashed>false</Trashed>
    <ContentType>blogPost</ContentType>
    <CreateDate>2016-08-08T07:21:34</CreateDate>
    <NodeName Default="Let's Encrypt on Windows revisited" />
    <SortOrder>47</SortOrder>
    <Published Default="true" />
    <Schedule />
    <Template Key="a649a8ca-c7c4-4bd2-a252-d002b5483d44">BlogPost</Template>
  </Info>
  <Properties>
    <bodyText>
      <Value><![CDATA[{
  "markup": "\u003Cp\u003EBack in March, I \u003Ca data-id=\u00221650\u0022 href=\u0022/{localLink:30f2acbe-5336-477b-bd56-81bd54da1b05}\u0022 type=\u0022document\u0022 title=\u0022Let\u0027s Encrypt, on Windows\u0022 data-udi=\u0022umb://document/30f2acbe5336477bbd5681bd54da1b05\u0022\u003Eblogged about Let\u0027s Encrypt\u003C/a\u003E and then I got busy doing other things. This weekend I had\u00A0another look at the state of things for Windows and discovered that a few industrious people have been building some great things. The on tool I like very much is \u003Ca href=\u0022https://github.com/Lone-Coder/letsencrypt-win-simple\u0022\u003Elets-encrypt-win-simple\u003C/a\u003E\u00A0(lews).\u00A0This is a small command line application that accepts some parameters to make obtaining a certificate as easy as possible. It supports installing certs into IIS and can set up an automated renewal process as well.\u003C/p\u003E\n\u003Cp\u003EThe best part about lews is that I can read the source code and understand what\u0027s going on, hurrah for keeping it fairly simple! The second best part was that I could really quickly develop a plugin for it. What I wanted to do is\u00A0to fully automate obtaining the certificate. Currently it\u0027s not yet possible for me to automate the install of the certificate but (at Umbraco) we\u0027re working at making that possible as well.\u003C/p\u003E\n\u003Cp\u003EIf you\u0027ve read my previous blog post, you know that Let\u0027s Encrypt needs to verify that you own the domain you\u0027re trying to purchase a certificate for. Let\u0027s Encrypt tells you to put a file in your site with a verification token in it, that they can then read. I used to do this manually but it became tedious, so I \u003Ca href=\u0022https://gist.github.com/nul800sebastiaan/4999468e3097e2147d54c06daa8ffb26\u0022\u003Ewrote a quick ApiController\u003C/a\u003E so I can just tell my site: create a file, in folder x with content y. One warning though: \u003Cstrong\u003Ethis is VERY insecure\u003C/strong\u003E. I\u0027ve only secured it with a secret token right now but if you post to this endpoint over http, your request can be intercepted and random files can be written to your website!\u003C/p\u003E\n\u003Cp\u003ERight. A quick test \u003Ca href=\u0022https://www.getpostman.com/\u0022\u003Ewith Postman\u003C/a\u003E later and I\u0027m confident that I can now automatically create the verification that Let\u0027s Encrypt needs.\u003C/p\u003E\n\u003Cp\u003E\u003Cimg style=\u0022width: 700px; height:573.3629300776914px;\u0022 src=\u0022\u0022 alt=\u0022\u0022 rel=\u00221583\u0022 data-id=\u00220\u0022 data-udi=\u0022umb://media/32eea36ac1f54334bf92074045f1c6c8\u0022\u003E\u003C/p\u003E\n\u003Cp\u003ENow I need to tell\u00A0lets-encrypt-win-simple (can we just rename this to Lewis?) how to use this endpoint. Lewis (there, I did it!) allows for plugins to be built, just make a class that inherits from \u0060LetsEncrypt.ACME.Simple.Plugin\u0060 and implement the methods you get. I took a peak at their FTP plugin and borrowed some code from that one.\u003C/p\u003E\n\u003Cp\u003EIn order to show up in the lews\u00A0dialog you need to implement a \u0060public override void PrintMenu()\u0060 method that tells you something like: \u0022X: press x for my plugin\u0022. Then you can handle the keypess in a HandleMenuResponse method that you override and in which you test if \u0022X\u0022 has been pressed. That\u0027s it, we\u0027re in business! We can now do whatever we want.\u003C/p\u003E\n\u003Cp\u003EA bit of code:\u003C/p\u003E\n\u003Cp\u003E\u003Cimg style=\u0022width: 555px; height:131px;\u0022 src=\u0022\u0022 alt=\u0022\u0022 rel=\u00221692\u0022 data-id=\u00220\u0022 data-udi=\u0022umb://media/db20a2a786ff47138f0bf171a2011e35\u0022\u003E\u003C/p\u003E\n\u003Cp\u003EResults in an extra menu option:\u003C/p\u003E\n\u003Cp\u003E\u003Cimg style=\u0022width: 700px; height:366.0878447395301px;\u0022 src=\u0022\u0022 alt=\u0022\u0022 rel=\u00221620\u0022 data-id=\u00220\u0022 data-udi=\u0022umb://media/698b554158c4499186b5791b8991b7ec\u0022\u003E\u003C/p\u003E\n\u003Cp\u003EThe prompt here is a bit deceiving, but instead of giving it a host to get a certificate for, you enter one of the menu options.\u003C/p\u003E\n\u003Cp\u003EThe code then needs to create a target (basically: a hostname for which to create a certificate) and call the \u0060Auto\u0060 method, passing in this target:\u003C/p\u003E\n\u003Cpre\u003E    public override void HandleMenuResponse(string response, List targets)\n    {\n        if (response != \u0022c\u0022.ToLowerInvariant()) return;\n\n        var target = new Target\n        {\n            Host = \u0022cork.nl\u0022,\n            WebRootPath = string.Empty,\n            PluginName = Name\n        };\n\n        Auto(target);\n    }\n\u003C/pre\u003E\n\u003Cp\u003EOf course\u00A0you wouldn\u0027t have hard coded domains in there, this is just a proof of concept to see if it works.\u003C/p\u003E\n\u003Cp\u003EThen it get\u0027s really interesting, Lewis (I always imagine people with the name Lewis have\u00A0a moustache) will look for a method called \u0060CreateAuthorizationFile\u0060 which is where we can call our endpoint with the directory name to create and the contents of the authorization file:\u003C/p\u003E\n\u003Cpre\u003E    public override void CreateAuthorizationFile(string answerPath, string fileContents)\n    {\n        const string token = \u0022not_my_real_secret\u0022;\n        var endpoint = new Uri(\u0022https://cork.nl/umbraco/api/Certificate/ValidationFile/\u0022);\n        var directoryName = answerPath.Split(\u0027/\u0027).Last();\n        var parameters = string.Format(\n            \u0022DirectoryName={0}\u0026amp;FileContent={1}\u0026amp;Token={2}\u0022, directoryName, fileContents, token);\n\n        using (var web = new WebClient())\n        {\n            web.Headers[HttpRequestHeader.ContentType] = \u0022application/x-www-form-urlencoded\u0022;\n            web.UploadString(endpoint, parameters);\n        }\n    }\n\u003C/pre\u003E\n\u003Cp\u003E\u00A0This makes Let\u0027s Encrypt happy and they\u00A0send\u00A0me a certificate!\u003C/p\u003E\n\u003Cp\u003E\u003Cimg style=\u0022width: 700px; height:366.0878447395301px;\u0022 src=\u0022\u0022 alt=\u0022\u0022 rel=\u00221552\u0022 data-id=\u00220\u0022 data-udi=\u0022umb://media/119697466c0548ff8cc941555de088d3\u0022\u003E\u003C/p\u003E\n\u003Cp\u003EThough I am happy with this result, I do wish I could do all this with just a few command line switches so that I don\u0027t need to manually tell\u00A0Lewis (it\u0027s sticky, isn\u0027t it!) what to do every time I start it. Full automation \u003Ca href=\u0022https://github.com/Lone-Coder/letsencrypt-win-simple/issues/151\u0022\u003Eis on their roadmap\u003C/a\u003E and I\u0027ve sent them \u003Ca href=\u0022https://github.com/Lone-Coder/letsencrypt-win-simple/pull/275\u0022\u003Ea simple pull request\u003C/a\u003E to get started. For now, I\u0027ll work with my fork which has this logic in it already.\u003C/p\u003E\n\u003Cp\u003EWhat\u0027s not covered in this post, is the \u0060Install\u0060 method, in which you can\u00A0code how exactly to install the certificate on your target server. You can get some inspiration from the built-in plugins for that of course!\u003C/p\u003E\n\u003Cp\u003EAll in all, I\u0027m happy that things are moving fast on the Windows side of Let\u0027s Encrypt and we\u0027ll definitely have a bright and encrypted future ahead of us!\u003C/p\u003E\n\u003Cp\u003E\u00A0\u003C/p\u003E",
  "blocks": {
    "contentData": [],
    "settingsData": [],
    "expose": [],
    "Layout": {}
  }
}]]></Value>
    </bodyText>
    <image>
      <Value><![CDATA[umb://media/149818c30baa45deac44dcc574b4934f]]></Value>
    </image>
    <pageTitle>
      <Value><![CDATA[]]></Value>
    </pageTitle>
    <searchEngineSitemapChangeFrequency>
      <Value><![CDATA[]]></Value>
    </searchEngineSitemapChangeFrequency>
    <searchEngineSitemapPriority>
      <Value><![CDATA[]]></Value>
    </searchEngineSitemapPriority>
    <stillRelevant>
      <Value><![CDATA[0]]></Value>
    </stillRelevant>
    <umbracoNaviHide>
      <Value><![CDATA[]]></Value>
    </umbracoNaviHide>
  </Properties>
</Content>